using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;
using Responsible.Context;
using Responsible.TestInstructions;
using UniRx;

namespace Responsible
{
	public static class TestInstruction
	{
		/// <summary>
		/// Returns an observable which executes the instruction when subscribed to.
		/// </summary>
		[Pure]
		public static IObservable<T> ToObservable<T>(
			this ITestInstruction<T> instruction,
			TestInstructionExecutor executor,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0)
			=> executor.RunInstruction(
				instruction.CreateState(),
				new SourceContext(nameof(ToObservable), memberName, sourceFilePath, sourceLineNumber));

		/// <summary>
		/// Starts executing an instruction, and returns a yield instruction which can be waited upon.
		/// </summary>
		[Pure]
		public static ObservableYieldInstruction<T> ToYieldInstruction<T>(
			this ITestInstruction<T> instruction,
			TestInstructionExecutor executor,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0)
			=> executor.RunInstruction(
				instruction.CreateState(),
				new SourceContext(nameof(ToYieldInstruction), memberName, sourceFilePath, sourceLineNumber))
				.ToYieldInstruction();

		/// <summary>
		/// Runs all provided test instructions in order, or until one of them fails.
		/// </summary>
		[Pure]
		public static ITestInstruction<Unit> Sequence(
			this IEnumerable<ITestInstruction<Unit>> instructions,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0) =>
			instructions.Aggregate((sequencedInstructions, nextInstruction) =>
				new SequencedTestInstruction<Unit, Unit>(
					sequencedInstructions,
					nextInstruction,
					new SourceContext(nameof(Sequence), memberName, sourceFilePath, sourceLineNumber)));

		/// <summary>
		/// Constructs a test instruction, which will construct another instruction using <c>continuation</c>
		/// once the first instruction has completed, and then continue executing the constructed instruction.
		/// Returns the result of the second instruction.
		/// </summary>
		[Pure]
		public static ITestInstruction<T2> ContinueWith<T1, T2>(
			this ITestInstruction<T1> first,
			Func<T1, ITestInstruction<T2>> continuation,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0)
			=> new ContinuationTestInstruction<T1, T2>(
				first,
				continuation,
				new SourceContext(nameof(ContinueWith), memberName, sourceFilePath, sourceLineNumber));

		/// <summary>
		/// Sequences to test instructions to be executed in order. Returns the result of the second instruction.
		/// </summary>
		[Pure]
		public static ITestInstruction<T2> ContinueWith<T1, T2>(
			this ITestInstruction<T1> first,
			ITestInstruction<T2> second,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0)
			=> new SequencedTestInstruction<T1, T2>(
				first,
				second,
				new SourceContext(nameof(ContinueWith), memberName, sourceFilePath, sourceLineNumber));

		/// <summary>
		/// Applies a selector to the result of a test instruction.
		/// </summary>
		/// <param name="instruction">A test instruction to apply the selector to.</param>
		/// <param name="selector">A function to apply to the result of the instruction.</param>
		/// <returns>
		/// A test instruction whose result is the result of invoking <c>selector</c> on the result of <c>instruction</c>
		/// </returns>
		/// <inheritdoc cref="Docs.Provider.CallerMember{T1,T2}"/>
		[Pure]
		public static ITestInstruction<T2> Select<T1, T2>(
			this ITestInstruction<T1> instruction,
			Func<T1, T2> selector,
			[CallerMemberName] string memberName = "",
			[CallerFilePath] string sourceFilePath = "",
			[CallerLineNumber] int sourceLineNumber = 0)
			=> new SelectTestInstruction<T1, T2>(
				instruction,
				selector,
				new SourceContext(nameof(Select), memberName, sourceFilePath, sourceLineNumber));

		/// <summary>
		/// Converts a test instruction returning any value to one returning <see cref="Unit"/>.
		/// Can be useful for example for using <see cref="Sequence"/>.
		/// </summary>
		[Pure]
		public static ITestInstruction<Unit> AsUnitInstruction<T>(
			this ITestInstruction<T> instruction) =>
			typeof(T) == typeof(Unit)
				? (ITestInstruction<Unit>)instruction
				: new UnitTestInstruction<T>(instruction);
	}
}
