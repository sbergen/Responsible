using System.CommandLine;
using System.CommandLine.IO;
using System.IO.Abstractions.TestingHelpers;
using System.Threading.Tasks;
using FluentAssertions;
using ResponsibleGherkin.Generators;
using VerifyXunit;
using Xunit;
using static VerifyXunit.Verifier;

namespace ResponsibleGherkin.Tests;

[UsesVerify]
public class ProgramTests
{
	private readonly MockFileSystem fileSystem = new();
	private readonly TestConsole console = new();

	public ProgramTests()
	{
		this.fileSystem.AddFile(
			"config.json",
			TestData.DefaultConfigurationAsComments);

		this.fileSystem.AddFile(
			"partialConfig.json",
			@"
# responsible-indent: 1 tab
# responsible-flavor: xunit
# responsible-executor: Executor
# responsible-base-class: MyTestBase");

		this.fileSystem.AddFile(
			"MinimalFeature.feature",
			TestData.MinimalFeatureContent);

		this.fileSystem.AddFile(
			"PartialConfigFeature.feature",
			TestData.PartialConfigFeatureContent);

		this.fileSystem.AddFile(
			"UnsupportedKeyword.feature",
			TestData.UnsupportedKeywordFeatureContent);

		this.fileSystem.AddFile(
			"InvalidFeature.feature",
			"foobar");
	}

	[Fact]
	public async Task Verify_Output_WhenNoArguments()
	{
		this.RunAssertingFailure();
		await Verify(this.FullConsoleOutput());
	}

	[Fact]
	public void Generate_ProducesSameResultAsManualInvoke_WithConfigFile()
	{
		var expected = CodeGenerator.GenerateClass(
				TestData.LoadFeature(TestData.MinimalFeature).Feature,
				TestData.DefaultConfiguration)
			.BuildFileContent();

		this.RunAssertingSuccess("-c", "config.json", "MinimalFeature.feature", "./");
		var generatedContent = this.fileSystem.File.ReadAllText("MinimalFeature.cs");

		generatedContent.Should().Be(
			expected,
			"it should match code generated by invoking CodeGenerator directly");
	}

	[Fact]
	public void Generate_ProducesSameResultAsManualInvoke_WithoutConfigFile()
	{
		var expected = CodeGenerator.GenerateClass(
				TestData.LoadFeature(TestData.MinimalFeature).Feature,
				TestData.DefaultConfiguration with
				{
					Flavor = FlavorType.Unity, // Should be coming from Program defaults
					IndentInfo = IndentInfo.Tabs, // Should be coming from .editorconfig
				})
			.BuildFileContent();

		this.RunAssertingSuccess("MinimalFeature.feature", "./");
		var generatedContent = this.fileSystem.File.ReadAllText("MinimalFeature.cs");

		generatedContent.Should().Be(
			expected,
			"it should match code generated by invoking CodeGenerator directly");
	}

	[Fact]
	public void Generate_OutputContainsGeneratedFile()
	{
		this.RunAssertingSuccess("MinimalFeature.feature");
		this.ConsoleOutput().Should().ContainAll("Wrote file", "MinimalFeature.cs");
	}

	[Fact]
	public void Generate_ProducesSameResultAsManualInvoke_WithPartialConfig()
	{
		var expected = CodeGenerator.GenerateClass(
				TestData.LoadFeature(TestData.PartialConfigFeature).Feature,
				TestData.DefaultConfiguration with { BaseClass = "MyTestBaseOverride" })
			.BuildFileContent();

		this.RunAssertingSuccess("-c", "partialConfig.json", "PartialConfigFeature.feature", "./");
		var generatedContent = this.fileSystem.File.ReadAllText("PartialConfigFeature.cs");

		generatedContent.Should().Be(
			expected,
			"it should match code generated by invoking CodeGenerator directly");
	}

	[Fact]
	public void Generate_ProducesMeaningfulError_WhenConfigurationIsPartial()
	{
		this.RunAssertingFailure("-c", "partialConfig.json", "MinimalFeature.feature", "./");

		this.ConsoleErrors().Should().ContainAll(
			"merge configurations", "missing", "properties");
	}

	[Fact]
	public void Generate_ContainsDescriptiveError_WhenConfigFileIsMissing()
	{
		this.RunAssertingFailure("-c", "foobar", "MinimalFeature.feature", "./");
		this.ConsoleErrors().Should().Contain("read configuration");
	}

	[Fact]
	public void Generate_ContainsDescriptiveError_WhenInputFileIsMissing()
	{
		this.RunAssertingFailure("-c", "config.json", "foobar", "./");
		this.ConsoleErrors().Should().Contain("read input");
	}

	[Fact]
	public void Generate_ContainsDescriptiveError_WhenInputFileIsInvalid()
	{
		this.RunAssertingFailure("-c", "config.json", "InvalidFeature.feature", "./");
		this.ConsoleErrors().Should().ContainAll("read input", "Parser errors");
	}

	[Fact]
	public void Generate_ContainsDescriptiveError_WhenInputFileIsNotSupported()
	{
		this.RunAssertingFailure("-c", "config.json", "UnsupportedKeyword.feature", "./");
		this.ConsoleErrors().Should().Contain("generate code");
	}

	[Fact]
	public void Generate_ContainsDescriptiveError_WhenDirectoryIsInvalid()
	{
		this.RunAssertingFailure("-c", "config.json", "MinimalFeature.feature", "*");
		this.ConsoleErrors().Should().Contain("write output");
	}

	[Fact]
	public void Generate_CreatesOutputDirectory_WhenItDoesNotExist()
	{
		this.RunAssertingSuccess("-c", "config.json", "MinimalFeature.feature", "./Output");
		this.fileSystem.Directory.Exists("Output").Should().BeTrue("it should be created");
		this.fileSystem.File.Exists("Output/MinimalFeature.cs").Should().BeTrue("the file should be generated");
	}

	[Fact]
	public void Generate_ReturnsError_WhenOutputFileExists()
	{
		this.fileSystem.AddFile("MinimalFeature.cs", "");
		this.RunAssertingFailure("MinimalFeature.feature");
		this.ConsoleErrors().Should()
			.ContainAll("Output file", "MinimalFeature.cs", "already exists");
	}

	[Fact]
	public void Generate_OverwritesContent_WhenForceSpecified()
	{
		this.fileSystem.AddFile("MinimalFeature.cs", "");
		this.RunAssertingSuccess("MinimalFeature.feature", "-f");
		this.fileSystem.GetFile("MinimalFeature.cs").TextContents.Should().NotBeEmpty();
	}

	private void RunAssertingFailure(params string[] args)
	{
		this.Run(args).Should().NotBe(0, $"the run should fail, output was {this.console.Out}");
	}

	private void RunAssertingSuccess(params string[] args)
	{
		this.Run(args).Should().Be(0, $"Run should succeed, failed with {this.console.Error}");
	}

	private int Run(params string[] args) => Program
		.BuildRootCommand(this.fileSystem)
		.Invoke(args, this.console);

	private object FullConsoleOutput() => new
	{
		Out = this.ConsoleOutput(),
		Error = this.ConsoleErrors(),
	};

	private string? ConsoleErrors() => this.console.Error.ToString();
	private string? ConsoleOutput() => this.console.Out.ToString();
}
